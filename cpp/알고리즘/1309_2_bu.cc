/*
https://www.acmicpc.net/problem/1309
1309 다이나믹 문제풀이2 Bottom Up
d[n] 2xn 배열에서 n자리에 사자가 있을 경우 사자를 배치하는 경우의 수
array s[n-S] : Σ sol(n-L) (S <= L <= n)
d[n] = s[n-2]*2 + d[n-1]
d[0] = 1, d[1] = 2
s[0] = 1, s[1] = d[1] + s[0]
ans = sol(n) + s[n-1]
=========================================================================
d[n]은 크게 두가지로 분류할 수 있는데,
1. 2x(n-1)자리에 사자가 없는 경우
2. 2x(n-1)자리에 사자가 있는 경우

1의 경우 2x(n-1)자리에 사자가 없으므로
2x(n-2)자리부터 2x1자리 까지 사자가 있을 수도 있고 없을 수도 있다.
이때 sol(n)은 n에 반드시 사자가 있는 경우 배치하는 경우의 수 이므로
이때 경우의 수는 d[n-2] + d[n-3] + ... + d[0]이다.
** 2x(n-2)에 사자가 없는 경우의 경우의 수는 d[n-3]와 같기 때문이다.
이때, 2xn에 사자는 왼쪽 오른쪽에 각각 1번씩 둘 수 있으므로, 위의 점화식에 2배를 한 것과 같다.
따라서 1의 경우의 수는 Σ 2*d[n-L] (2 <= L <= n)이 된다.

2의 경우 2x(n-1)자리에 사자가 있으므로,
이는 d[n-1]과 같다.
따라서 2의 경우의 수는 d[n-1]이 된다.

d[n]은 1의 경우의 수와 2의 경우의 수의 합이므로,
d[n] = Σ 2*d[n-L] + d[n-1] (2 <= L <= n)이 된다.
array s[n-S] : Σ d[n-L] (S <= L <= n)이라 정의할 때,
d[n] = 2*s[n-2] + d[n-1]이다. (n >= 2)

여기서 d[n]이 비어있는 경우도 포함되므로,
위 문제의 답은 d[n] + s[n-1]이 된다.
==========================================================================
*/

#include <iostream>
#include <array>

using namespace std;
array<int, 100001> d, s;
const int mod = 9901;

int main()
{
    int n;
    cin >> n;
    d[0] = s[0] = 1;
    d[1] = 2;
    s[1] = d[0] + d[1];
    for(int i = 2; i <= n; ++i)
    {
        d[i] = 2*s[i-2]+d[i-1];
        s[i] = s[i-1]+d[i];
        d[i] %= mod;
        s[i] %= mod;
    }
    cout << (d[n] + s[n-1]) % mod << '\n';
    return 0;
}